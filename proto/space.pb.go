// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/space.proto

package riseandfall

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Space struct {
	Planets              map[uint32]*Planet `protobuf:"bytes,1,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Fleets               map[uint32]*Fleet  `protobuf:"bytes,2,rep,name=fleets" json:"fleets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Empires              map[uint32]*Empire `protobuf:"bytes,3,rep,name=empires" json:"empires,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Width                uint32             `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height               uint32             `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Round                uint64             `protobuf:"varint,6,opt,name=round,proto3" json:"round,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Space) Reset()      { *m = Space{} }
func (*Space) ProtoMessage() {}
func (*Space) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_8c7eb467fc9a111c, []int{0}
}
func (m *Space) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Space) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Space.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Space) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Space.Merge(dst, src)
}
func (m *Space) XXX_Size() int {
	return m.Size()
}
func (m *Space) XXX_DiscardUnknown() {
	xxx_messageInfo_Space.DiscardUnknown(m)
}

var xxx_messageInfo_Space proto.InternalMessageInfo

func (m *Space) GetPlanets() map[uint32]*Planet {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Space) GetFleets() map[uint32]*Fleet {
	if m != nil {
		return m.Fleets
	}
	return nil
}

func (m *Space) GetEmpires() map[uint32]*Empire {
	if m != nil {
		return m.Empires
	}
	return nil
}

func (m *Space) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Space) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Space) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type Fleet struct {
	Empire uint32 `protobuf:"varint,1,opt,name=empire,proto3" json:"empire,omitempty"`
	// cannot use enum as map key
	// 1 ligth 2 heavy 3 ranged
	Ships                map[uint32]uint64 `protobuf:"bytes,2,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Position             uint32            `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Fleet) Reset()      { *m = Fleet{} }
func (*Fleet) ProtoMessage() {}
func (*Fleet) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_8c7eb467fc9a111c, []int{1}
}
func (m *Fleet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fleet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fleet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Fleet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fleet.Merge(dst, src)
}
func (m *Fleet) XXX_Size() int {
	return m.Size()
}
func (m *Fleet) XXX_DiscardUnknown() {
	xxx_messageInfo_Fleet.DiscardUnknown(m)
}

var xxx_messageInfo_Fleet proto.InternalMessageInfo

func (m *Fleet) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

func (m *Fleet) GetShips() map[uint32]uint64 {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Fleet) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

type Planet struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id   uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	PosX uint32 `protobuf:"varint,3,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY uint32 `protobuf:"varint,4,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
	// fleetid
	Fleets               []uint32 `protobuf:"varint,5,rep,packed,name=fleets" json:"fleets,omitempty"`
	Control              float32  `protobuf:"fixed32,6,opt,name=control,proto3" json:"control,omitempty"`
	Empire               uint32   `protobuf:"varint,7,opt,name=empire,proto3" json:"empire,omitempty"`
	Connected            []uint32 `protobuf:"varint,8,rep,packed,name=connected" json:"connected,omitempty"`
	Production           float32  `protobuf:"fixed32,9,opt,name=production,proto3" json:"production,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Planet) Reset()      { *m = Planet{} }
func (*Planet) ProtoMessage() {}
func (*Planet) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_8c7eb467fc9a111c, []int{2}
}
func (m *Planet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Planet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Planet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Planet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Planet.Merge(dst, src)
}
func (m *Planet) XXX_Size() int {
	return m.Size()
}
func (m *Planet) XXX_DiscardUnknown() {
	xxx_messageInfo_Planet.DiscardUnknown(m)
}

var xxx_messageInfo_Planet proto.InternalMessageInfo

func (m *Planet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Planet) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Planet) GetPosX() uint32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *Planet) GetPosY() uint32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *Planet) GetFleets() []uint32 {
	if m != nil {
		return m.Fleets
	}
	return nil
}

func (m *Planet) GetControl() float32 {
	if m != nil {
		return m.Control
	}
	return 0
}

func (m *Planet) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

func (m *Planet) GetConnected() []uint32 {
	if m != nil {
		return m.Connected
	}
	return nil
}

func (m *Planet) GetProduction() float32 {
	if m != nil {
		return m.Production
	}
	return 0
}

type Empire struct {
	Id                   uint32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Passive              bool            `protobuf:"varint,2,opt,name=passive,proto3" json:"passive,omitempty"`
	Planets              map[uint32]bool `protobuf:"bytes,3,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Fleets               map[uint32]bool `protobuf:"bytes,4,rep,name=fleets" json:"fleets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Color                string          `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Empire) Reset()      { *m = Empire{} }
func (*Empire) ProtoMessage() {}
func (*Empire) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_8c7eb467fc9a111c, []int{3}
}
func (m *Empire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empire.Merge(dst, src)
}
func (m *Empire) XXX_Size() int {
	return m.Size()
}
func (m *Empire) XXX_DiscardUnknown() {
	xxx_messageInfo_Empire.DiscardUnknown(m)
}

var xxx_messageInfo_Empire proto.InternalMessageInfo

func (m *Empire) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Empire) GetPassive() bool {
	if m != nil {
		return m.Passive
	}
	return false
}

func (m *Empire) GetPlanets() map[uint32]bool {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Empire) GetFleets() map[uint32]bool {
	if m != nil {
		return m.Fleets
	}
	return nil
}

func (m *Empire) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func init() {
	proto.RegisterType((*Space)(nil), "riseandfall.Space")
	proto.RegisterMapType((map[uint32]*Empire)(nil), "riseandfall.Space.EmpiresEntry")
	proto.RegisterMapType((map[uint32]*Fleet)(nil), "riseandfall.Space.FleetsEntry")
	proto.RegisterMapType((map[uint32]*Planet)(nil), "riseandfall.Space.PlanetsEntry")
	proto.RegisterType((*Fleet)(nil), "riseandfall.Fleet")
	proto.RegisterMapType((map[uint32]uint64)(nil), "riseandfall.Fleet.ShipsEntry")
	proto.RegisterType((*Planet)(nil), "riseandfall.Planet")
	proto.RegisterType((*Empire)(nil), "riseandfall.Empire")
	proto.RegisterMapType((map[uint32]bool)(nil), "riseandfall.Empire.FleetsEntry")
	proto.RegisterMapType((map[uint32]bool)(nil), "riseandfall.Empire.PlanetsEntry")
}
func (this *Space) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Space)
	if !ok {
		that2, ok := that.(Space)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Planets) != len(that1.Planets) {
		return false
	}
	for i := range this.Planets {
		if !this.Planets[i].Equal(that1.Planets[i]) {
			return false
		}
	}
	if len(this.Fleets) != len(that1.Fleets) {
		return false
	}
	for i := range this.Fleets {
		if !this.Fleets[i].Equal(that1.Fleets[i]) {
			return false
		}
	}
	if len(this.Empires) != len(that1.Empires) {
		return false
	}
	for i := range this.Empires {
		if !this.Empires[i].Equal(that1.Empires[i]) {
			return false
		}
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	return true
}
func (this *Fleet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Fleet)
	if !ok {
		that2, ok := that.(Fleet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Empire != that1.Empire {
		return false
	}
	if len(this.Ships) != len(that1.Ships) {
		return false
	}
	for i := range this.Ships {
		if this.Ships[i] != that1.Ships[i] {
			return false
		}
	}
	if this.Position != that1.Position {
		return false
	}
	return true
}
func (this *Planet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Planet)
	if !ok {
		that2, ok := that.(Planet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PosX != that1.PosX {
		return false
	}
	if this.PosY != that1.PosY {
		return false
	}
	if len(this.Fleets) != len(that1.Fleets) {
		return false
	}
	for i := range this.Fleets {
		if this.Fleets[i] != that1.Fleets[i] {
			return false
		}
	}
	if this.Control != that1.Control {
		return false
	}
	if this.Empire != that1.Empire {
		return false
	}
	if len(this.Connected) != len(that1.Connected) {
		return false
	}
	for i := range this.Connected {
		if this.Connected[i] != that1.Connected[i] {
			return false
		}
	}
	if this.Production != that1.Production {
		return false
	}
	return true
}
func (this *Empire) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empire)
	if !ok {
		that2, ok := that.(Empire)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Passive != that1.Passive {
		return false
	}
	if len(this.Planets) != len(that1.Planets) {
		return false
	}
	for i := range this.Planets {
		if this.Planets[i] != that1.Planets[i] {
			return false
		}
	}
	if len(this.Fleets) != len(that1.Fleets) {
		return false
	}
	for i := range this.Fleets {
		if this.Fleets[i] != that1.Fleets[i] {
			return false
		}
	}
	if this.Color != that1.Color {
		return false
	}
	return true
}
func (this *Space) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&riseandfall.Space{")
	keysForPlanets := make([]uint32, 0, len(this.Planets))
	for k, _ := range this.Planets {
		keysForPlanets = append(keysForPlanets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPlanets)
	mapStringForPlanets := "map[uint32]*Planet{"
	for _, k := range keysForPlanets {
		mapStringForPlanets += fmt.Sprintf("%#v: %#v,", k, this.Planets[k])
	}
	mapStringForPlanets += "}"
	if this.Planets != nil {
		s = append(s, "Planets: "+mapStringForPlanets+",\n")
	}
	keysForFleets := make([]uint32, 0, len(this.Fleets))
	for k, _ := range this.Fleets {
		keysForFleets = append(keysForFleets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFleets)
	mapStringForFleets := "map[uint32]*Fleet{"
	for _, k := range keysForFleets {
		mapStringForFleets += fmt.Sprintf("%#v: %#v,", k, this.Fleets[k])
	}
	mapStringForFleets += "}"
	if this.Fleets != nil {
		s = append(s, "Fleets: "+mapStringForFleets+",\n")
	}
	keysForEmpires := make([]uint32, 0, len(this.Empires))
	for k, _ := range this.Empires {
		keysForEmpires = append(keysForEmpires, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForEmpires)
	mapStringForEmpires := "map[uint32]*Empire{"
	for _, k := range keysForEmpires {
		mapStringForEmpires += fmt.Sprintf("%#v: %#v,", k, this.Empires[k])
	}
	mapStringForEmpires += "}"
	if this.Empires != nil {
		s = append(s, "Empires: "+mapStringForEmpires+",\n")
	}
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Fleet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&riseandfall.Fleet{")
	s = append(s, "Empire: "+fmt.Sprintf("%#v", this.Empire)+",\n")
	keysForShips := make([]uint32, 0, len(this.Ships))
	for k, _ := range this.Ships {
		keysForShips = append(keysForShips, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForShips)
	mapStringForShips := "map[uint32]uint64{"
	for _, k := range keysForShips {
		mapStringForShips += fmt.Sprintf("%#v: %#v,", k, this.Ships[k])
	}
	mapStringForShips += "}"
	if this.Ships != nil {
		s = append(s, "Ships: "+mapStringForShips+",\n")
	}
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Planet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&riseandfall.Planet{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "PosX: "+fmt.Sprintf("%#v", this.PosX)+",\n")
	s = append(s, "PosY: "+fmt.Sprintf("%#v", this.PosY)+",\n")
	s = append(s, "Fleets: "+fmt.Sprintf("%#v", this.Fleets)+",\n")
	s = append(s, "Control: "+fmt.Sprintf("%#v", this.Control)+",\n")
	s = append(s, "Empire: "+fmt.Sprintf("%#v", this.Empire)+",\n")
	s = append(s, "Connected: "+fmt.Sprintf("%#v", this.Connected)+",\n")
	s = append(s, "Production: "+fmt.Sprintf("%#v", this.Production)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empire) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&riseandfall.Empire{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Passive: "+fmt.Sprintf("%#v", this.Passive)+",\n")
	keysForPlanets := make([]uint32, 0, len(this.Planets))
	for k, _ := range this.Planets {
		keysForPlanets = append(keysForPlanets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPlanets)
	mapStringForPlanets := "map[uint32]bool{"
	for _, k := range keysForPlanets {
		mapStringForPlanets += fmt.Sprintf("%#v: %#v,", k, this.Planets[k])
	}
	mapStringForPlanets += "}"
	if this.Planets != nil {
		s = append(s, "Planets: "+mapStringForPlanets+",\n")
	}
	keysForFleets := make([]uint32, 0, len(this.Fleets))
	for k, _ := range this.Fleets {
		keysForFleets = append(keysForFleets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFleets)
	mapStringForFleets := "map[uint32]bool{"
	for _, k := range keysForFleets {
		mapStringForFleets += fmt.Sprintf("%#v: %#v,", k, this.Fleets[k])
	}
	mapStringForFleets += "}"
	if this.Fleets != nil {
		s = append(s, "Fleets: "+mapStringForFleets+",\n")
	}
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSpace(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Space) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Space) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0xa
			i++
			v := m.Planets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Fleets) > 0 {
		for k, _ := range m.Fleets {
			dAtA[i] = 0x12
			i++
			v := m.Fleets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Empires) > 0 {
		for k, _ := range m.Empires {
			dAtA[i] = 0x1a
			i++
			v := m.Empires[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Height))
	}
	if m.Round != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Round))
	}
	return i, nil
}

func (m *Fleet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fleet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empire != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	if len(m.Ships) > 0 {
		for k, _ := range m.Ships {
			dAtA[i] = 0x12
			i++
			v := m.Ships[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + sovSpace(uint64(v))
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintSpace(dAtA, i, uint64(v))
		}
	}
	if m.Position != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Position))
	}
	return i, nil
}

func (m *Planet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Planet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.PosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosY))
	}
	if len(m.Fleets) > 0 {
		dAtA5 := make([]byte, len(m.Fleets)*10)
		var j4 int
		for _, num := range m.Fleets {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.Control != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Control))))
		i += 4
	}
	if m.Empire != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		dAtA7 := make([]byte, len(m.Connected)*10)
		var j6 int
		for _, num := range m.Connected {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintSpace(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.Production != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Production))))
		i += 4
	}
	return i, nil
}

func (m *Empire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empire) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.Passive {
		dAtA[i] = 0x10
		i++
		if m.Passive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0x1a
			i++
			v := m.Planets[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Fleets) > 0 {
		for k, _ := range m.Fleets {
			dAtA[i] = 0x22
			i++
			v := m.Fleets[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Color) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Color)))
		i += copy(dAtA[i:], m.Color)
	}
	return i, nil
}

func encodeVarintSpace(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Fleets) > 0 {
		for k, v := range m.Fleets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Empires) > 0 {
		for k, v := range m.Empires {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Width != 0 {
		n += 1 + sovSpace(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovSpace(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovSpace(uint64(m.Round))
	}
	return n
}

func (m *Fleet) Size() (n int) {
	var l int
	_ = l
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	if len(m.Ships) > 0 {
		for k, v := range m.Ships {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + sovSpace(uint64(v))
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Position != 0 {
		n += 1 + sovSpace(uint64(m.Position))
	}
	return n
}

func (m *Planet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.PosX != 0 {
		n += 1 + sovSpace(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovSpace(uint64(m.PosY))
	}
	if len(m.Fleets) > 0 {
		l = 0
		for _, e := range m.Fleets {
			l += sovSpace(uint64(e))
		}
		n += 1 + sovSpace(uint64(l)) + l
	}
	if m.Control != 0 {
		n += 5
	}
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		l = 0
		for _, e := range m.Connected {
			l += sovSpace(uint64(e))
		}
		n += 1 + sovSpace(uint64(l)) + l
	}
	if m.Production != 0 {
		n += 5
	}
	return n
}

func (m *Empire) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.Passive {
		n += 2
	}
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Fleets) > 0 {
		for k, v := range m.Fleets {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	return n
}

func sovSpace(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSpace(x uint64) (n int) {
	return sovSpace(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Space) String() string {
	if this == nil {
		return "nil"
	}
	keysForPlanets := make([]uint32, 0, len(this.Planets))
	for k, _ := range this.Planets {
		keysForPlanets = append(keysForPlanets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPlanets)
	mapStringForPlanets := "map[uint32]*Planet{"
	for _, k := range keysForPlanets {
		mapStringForPlanets += fmt.Sprintf("%v: %v,", k, this.Planets[k])
	}
	mapStringForPlanets += "}"
	keysForFleets := make([]uint32, 0, len(this.Fleets))
	for k, _ := range this.Fleets {
		keysForFleets = append(keysForFleets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFleets)
	mapStringForFleets := "map[uint32]*Fleet{"
	for _, k := range keysForFleets {
		mapStringForFleets += fmt.Sprintf("%v: %v,", k, this.Fleets[k])
	}
	mapStringForFleets += "}"
	keysForEmpires := make([]uint32, 0, len(this.Empires))
	for k, _ := range this.Empires {
		keysForEmpires = append(keysForEmpires, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForEmpires)
	mapStringForEmpires := "map[uint32]*Empire{"
	for _, k := range keysForEmpires {
		mapStringForEmpires += fmt.Sprintf("%v: %v,", k, this.Empires[k])
	}
	mapStringForEmpires += "}"
	s := strings.Join([]string{`&Space{`,
		`Planets:` + mapStringForPlanets + `,`,
		`Fleets:` + mapStringForFleets + `,`,
		`Empires:` + mapStringForEmpires + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Fleet) String() string {
	if this == nil {
		return "nil"
	}
	keysForShips := make([]uint32, 0, len(this.Ships))
	for k, _ := range this.Ships {
		keysForShips = append(keysForShips, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForShips)
	mapStringForShips := "map[uint32]uint64{"
	for _, k := range keysForShips {
		mapStringForShips += fmt.Sprintf("%v: %v,", k, this.Ships[k])
	}
	mapStringForShips += "}"
	s := strings.Join([]string{`&Fleet{`,
		`Empire:` + fmt.Sprintf("%v", this.Empire) + `,`,
		`Ships:` + mapStringForShips + `,`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Planet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Planet{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`PosX:` + fmt.Sprintf("%v", this.PosX) + `,`,
		`PosY:` + fmt.Sprintf("%v", this.PosY) + `,`,
		`Fleets:` + fmt.Sprintf("%v", this.Fleets) + `,`,
		`Control:` + fmt.Sprintf("%v", this.Control) + `,`,
		`Empire:` + fmt.Sprintf("%v", this.Empire) + `,`,
		`Connected:` + fmt.Sprintf("%v", this.Connected) + `,`,
		`Production:` + fmt.Sprintf("%v", this.Production) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empire) String() string {
	if this == nil {
		return "nil"
	}
	keysForPlanets := make([]uint32, 0, len(this.Planets))
	for k, _ := range this.Planets {
		keysForPlanets = append(keysForPlanets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPlanets)
	mapStringForPlanets := "map[uint32]bool{"
	for _, k := range keysForPlanets {
		mapStringForPlanets += fmt.Sprintf("%v: %v,", k, this.Planets[k])
	}
	mapStringForPlanets += "}"
	keysForFleets := make([]uint32, 0, len(this.Fleets))
	for k, _ := range this.Fleets {
		keysForFleets = append(keysForFleets, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFleets)
	mapStringForFleets := "map[uint32]bool{"
	for _, k := range keysForFleets {
		mapStringForFleets += fmt.Sprintf("%v: %v,", k, this.Fleets[k])
	}
	mapStringForFleets += "}"
	s := strings.Join([]string{`&Empire{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Passive:` + fmt.Sprintf("%v", this.Passive) + `,`,
		`Planets:` + mapStringForPlanets + `,`,
		`Fleets:` + mapStringForFleets + `,`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSpace(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Space) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]*Planet)
			}
			var mapkey uint32
			var mapvalue *Planet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Planet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fleets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fleets == nil {
				m.Fleets = make(map[uint32]*Fleet)
			}
			var mapkey uint32
			var mapvalue *Fleet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Fleet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fleets[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empires == nil {
				m.Empires = make(map[uint32]*Empire)
			}
			var mapkey uint32
			var mapvalue *Empire
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Empire{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Empires[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fleet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fleet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fleet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ships == nil {
				m.Ships = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ships[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Planet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Planet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Planet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fleets = append(m.Fleets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpace
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fleets = append(m.Fleets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fleets", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Control = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Connected = append(m.Connected, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpace
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Connected = append(m.Connected, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Production", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Production = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]bool)
			}
			var mapkey uint32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fleets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fleets == nil {
				m.Fleets = make(map[uint32]bool)
			}
			var mapkey uint32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fleets[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpace(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSpace
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpace(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpace = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpace   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/space.proto", fileDescriptor_space_8c7eb467fc9a111c) }

var fileDescriptor_space_8c7eb467fc9a111c = []byte{
	// 568 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xcd, 0xf8, 0x95, 0xe4, 0xa6, 0x45, 0x30, 0x8d, 0xd0, 0x28, 0x82, 0xc1, 0xca, 0x2a, 0x48,
	0x28, 0x48, 0xad, 0x04, 0x6d, 0x96, 0x48, 0x65, 0x87, 0x8a, 0xdc, 0x0d, 0xac, 0x90, 0xb1, 0xa7,
	0xc4, 0xc2, 0xf5, 0x58, 0xb6, 0x53, 0xc8, 0x8e, 0x4f, 0xe0, 0x33, 0x10, 0x6b, 0x3e, 0x82, 0x65,
	0x97, 0xac, 0x10, 0x31, 0x1b, 0xc4, 0xaa, 0x9f, 0x80, 0xe6, 0x91, 0x64, 0x22, 0x1c, 0x55, 0xdd,
	0xcd, 0x1d, 0x9f, 0x73, 0xe6, 0x9e, 0xfb, 0x30, 0xdc, 0xc9, 0x0b, 0x5e, 0xf1, 0xc7, 0x65, 0x1e,
	0x46, 0x6c, 0x2c, 0xcf, 0xb8, 0x57, 0x24, 0x25, 0x0b, 0xb3, 0xf8, 0x2c, 0x4c, 0xd3, 0xe1, 0x5f,
	0x1b, 0xdc, 0x53, 0xf1, 0x11, 0x1f, 0x41, 0x3b, 0x4f, 0xc3, 0x8c, 0x55, 0x25, 0x41, 0xbe, 0x3d,
	0xea, 0xed, 0x3f, 0x18, 0x1b, 0xc0, 0xb1, 0x04, 0x8d, 0x5f, 0x2a, 0xc4, 0x71, 0x56, 0x15, 0xf3,
	0x60, 0x89, 0xc7, 0x4f, 0xc0, 0x3b, 0x4b, 0x99, 0x60, 0x5a, 0x92, 0x49, 0x1b, 0x98, 0xcf, 0x25,
	0x40, 0x11, 0x35, 0x5a, 0x3c, 0xc9, 0xce, 0xf3, 0xa4, 0x60, 0x25, 0xb1, 0xb7, 0x3e, 0x79, 0xac,
	0x10, 0xfa, 0x49, 0x8d, 0xc7, 0x7d, 0x70, 0x3f, 0x24, 0x71, 0x35, 0x25, 0x8e, 0x8f, 0x46, 0xbb,
	0x81, 0x0a, 0xf0, 0x5d, 0xf0, 0xa6, 0x2c, 0x79, 0x37, 0xad, 0x88, 0x2b, 0xaf, 0x75, 0x24, 0xd0,
	0x05, 0x9f, 0x65, 0x31, 0xf1, 0x7c, 0x34, 0x72, 0x02, 0x15, 0x0c, 0x4e, 0x60, 0xc7, 0xf4, 0x83,
	0x6f, 0x83, 0xfd, 0x9e, 0xcd, 0x09, 0x92, 0x54, 0x71, 0xc4, 0x0f, 0xc1, 0xbd, 0x08, 0xd3, 0x19,
	0x23, 0x96, 0x8f, 0x46, 0xbd, 0xfd, 0xbd, 0x8d, 0xf4, 0x14, 0x37, 0x50, 0x88, 0x89, 0x75, 0x88,
	0x06, 0x2f, 0xa0, 0x67, 0xd8, 0x6c, 0xd0, 0x1b, 0x6d, 0xea, 0xe1, 0x0d, 0x3d, 0x49, 0x35, 0xe5,
	0x4e, 0x60, 0xc7, 0x34, 0x7f, 0xd3, 0xfc, 0x14, 0xd7, 0x10, 0x1c, 0x7e, 0x45, 0xe0, 0xca, 0x57,
	0x44, 0xa1, 0x54, 0x25, 0xb5, 0x9a, 0x8e, 0xf0, 0x01, 0xb8, 0xe5, 0x34, 0xc9, 0x97, 0x8d, 0xbc,
	0xff, 0x7f, 0x82, 0xe3, 0x53, 0xf1, 0x5d, 0x75, 0x43, 0x61, 0xf1, 0x00, 0x3a, 0x39, 0x2f, 0x93,
	0x2a, 0xe1, 0x19, 0xb1, 0xa5, 0xdc, 0x2a, 0x1e, 0x1c, 0x02, 0xac, 0x09, 0x0d, 0x0e, 0xfa, 0xa6,
	0x03, 0xc7, 0x4c, 0xf6, 0x27, 0x02, 0x4f, 0x95, 0x18, 0x63, 0x70, 0xb2, 0xf0, 0x5c, 0xe5, 0xda,
	0x0d, 0xe4, 0x19, 0xdf, 0x02, 0x2b, 0x89, 0x25, 0x6b, 0x37, 0xb0, 0x92, 0x18, 0xef, 0x81, 0x9b,
	0xf3, 0xf2, 0xcd, 0x47, 0x9d, 0x81, 0x93, 0xf3, 0xf2, 0xd5, 0xf2, 0x72, 0xae, 0xa7, 0x44, 0x5c,
	0xbe, 0x16, 0xde, 0xf5, 0xb4, 0xba, 0xbe, 0x2d, 0xbc, 0xeb, 0x69, 0x24, 0xd0, 0x8e, 0x78, 0x56,
	0x15, 0x3c, 0x95, 0x63, 0x62, 0x05, 0xcb, 0xd0, 0xa8, 0x56, 0x7b, 0xa3, 0x5a, 0xf7, 0xa0, 0x1b,
	0xf1, 0x2c, 0x63, 0x51, 0xc5, 0x62, 0xd2, 0x91, 0x62, 0xeb, 0x0b, 0x4c, 0x01, 0xf2, 0x82, 0xc7,
	0xb3, 0x48, 0x16, 0xa6, 0x2b, 0x25, 0x8d, 0x9b, 0xe1, 0x37, 0x0b, 0x3c, 0xd5, 0x23, 0x6d, 0x06,
	0xad, 0xcc, 0x10, 0x68, 0xe7, 0x61, 0x59, 0x26, 0x17, 0xaa, 0x2e, 0x9d, 0x60, 0x19, 0xe2, 0xc9,
	0x7a, 0x4b, 0xd5, 0xca, 0xf8, 0x0d, 0x3d, 0xdf, 0xb2, 0xa6, 0x4f, 0x57, 0xc6, 0x9d, 0x86, 0x6d,
	0xd3, 0xd4, 0xa6, 0x3d, 0xed, 0x83, 0x1b, 0xf1, 0x94, 0x17, 0x72, 0xab, 0xba, 0x81, 0x0a, 0x06,
	0x93, 0x6b, 0xd7, 0x67, 0xa3, 0xb9, 0x1d, 0x73, 0xb4, 0x8f, 0xae, 0xdb, 0x94, 0xad, 0xd4, 0x67,
	0x8f, 0x2e, 0x17, 0xb4, 0xf5, 0x63, 0x41, 0x5b, 0x57, 0x0b, 0x8a, 0x3e, 0xd5, 0x14, 0x7d, 0xa9,
	0x29, 0xfa, 0x5e, 0x53, 0x74, 0x59, 0x53, 0xf4, 0xab, 0xa6, 0xe8, 0x4f, 0x4d, 0x5b, 0x57, 0x35,
	0x45, 0x9f, 0x7f, 0xd3, 0xd6, 0x5b, 0x4f, 0xfe, 0xf3, 0x0e, 0xfe, 0x05, 0x00, 0x00, 0xff, 0xff,
	0x20, 0x24, 0x8b, 0xbb, 0x08, 0x05, 0x00, 0x00,
}
