// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/space.proto

/*
Package riseandfall is a generated protocol buffer package.

It is generated from these files:
	proto/space.proto
	proto/command.proto
	proto/gameserver.proto

It has these top-level messages:
	ID
	Space
	Planet
	Ship
	Movement
	Empire
	Command
	MovementOrder
*/
package riseandfall

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ID struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ID) Reset()                    { *m = ID{} }
func (m *ID) String() string            { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()               {}
func (*ID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Space struct {
	Planets map[uint32]*Planet `protobuf:"bytes,1,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Ships   map[uint64]*Ship   `protobuf:"bytes,2,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Empires map[uint32]*Empire `protobuf:"bytes,3,rep,name=empires" json:"empires,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Width   uint32             `protobuf:"varint,4,opt,name=width" json:"width,omitempty"`
	Height  uint32             `protobuf:"varint,5,opt,name=height" json:"height,omitempty"`
	Round   uint64             `protobuf:"varint,6,opt,name=round" json:"round,omitempty"`
}

func (m *Space) Reset()                    { *m = Space{} }
func (m *Space) String() string            { return proto.CompactTextString(m) }
func (*Space) ProtoMessage()               {}
func (*Space) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Space) GetPlanets() map[uint32]*Planet {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Space) GetShips() map[uint64]*Ship {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Space) GetEmpires() map[uint32]*Empire {
	if m != nil {
		return m.Empires
	}
	return nil
}

func (m *Space) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Space) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Space) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type Planet struct {
	Name       string          `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Id         uint32          `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	PosX       uint32          `protobuf:"varint,3,opt,name=pos_x,json=posX" json:"pos_x,omitempty"`
	PosY       uint32          `protobuf:"varint,4,opt,name=pos_y,json=posY" json:"pos_y,omitempty"`
	Orbiting   map[uint64]bool `protobuf:"bytes,5,rep,name=orbiting" json:"orbiting,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Control    float32         `protobuf:"fixed32,6,opt,name=control" json:"control,omitempty"`
	Empire     uint32          `protobuf:"varint,7,opt,name=empire" json:"empire,omitempty"`
	Connected  []uint32        `protobuf:"varint,8,rep,packed,name=connected" json:"connected,omitempty"`
	Production float32         `protobuf:"fixed32,9,opt,name=production" json:"production,omitempty"`
}

func (m *Planet) Reset()                    { *m = Planet{} }
func (m *Planet) String() string            { return proto.CompactTextString(m) }
func (*Planet) ProtoMessage()               {}
func (*Planet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Planet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Planet) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Planet) GetPosX() uint32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *Planet) GetPosY() uint32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *Planet) GetOrbiting() map[uint64]bool {
	if m != nil {
		return m.Orbiting
	}
	return nil
}

func (m *Planet) GetControl() float32 {
	if m != nil {
		return m.Control
	}
	return 0
}

func (m *Planet) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

func (m *Planet) GetConnected() []uint32 {
	if m != nil {
		return m.Connected
	}
	return nil
}

func (m *Planet) GetProduction() float32 {
	if m != nil {
		return m.Production
	}
	return 0
}

type Ship struct {
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to Position:
	//	*Ship_Orbiting
	//	*Ship_Moving
	Position isShip_Position `protobuf_oneof:"position"`
	Empire   uint32          `protobuf:"varint,4,opt,name=empire" json:"empire,omitempty"`
}

func (m *Ship) Reset()                    { *m = Ship{} }
func (m *Ship) String() string            { return proto.CompactTextString(m) }
func (*Ship) ProtoMessage()               {}
func (*Ship) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isShip_Position interface {
	isShip_Position()
}

type Ship_Orbiting struct {
	Orbiting uint32 `protobuf:"varint,2,opt,name=orbiting,oneof"`
}
type Ship_Moving struct {
	Moving *Movement `protobuf:"bytes,3,opt,name=moving,oneof"`
}

func (*Ship_Orbiting) isShip_Position() {}
func (*Ship_Moving) isShip_Position()   {}

func (m *Ship) GetPosition() isShip_Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Ship) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Ship) GetOrbiting() uint32 {
	if x, ok := m.GetPosition().(*Ship_Orbiting); ok {
		return x.Orbiting
	}
	return 0
}

func (m *Ship) GetMoving() *Movement {
	if x, ok := m.GetPosition().(*Ship_Moving); ok {
		return x.Moving
	}
	return nil
}

func (m *Ship) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Ship) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Ship_OneofMarshaler, _Ship_OneofUnmarshaler, _Ship_OneofSizer, []interface{}{
		(*Ship_Orbiting)(nil),
		(*Ship_Moving)(nil),
	}
}

func _Ship_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Moving); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Ship.Position has unexpected type %T", x)
	}
	return nil
}

func _Ship_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Ship)
	switch tag {
	case 2: // position.orbiting
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Position = &Ship_Orbiting{uint32(x)}
		return true, err
	case 3: // position.moving
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Movement)
		err := b.DecodeMessage(msg)
		m.Position = &Ship_Moving{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Ship_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		s := proto.Size(x.Moving)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Movement struct {
	Start    uint32  `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	End      uint32  `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	Traveled float64 `protobuf:"fixed64,3,opt,name=traveled" json:"traveled,omitempty"`
}

func (m *Movement) Reset()                    { *m = Movement{} }
func (m *Movement) String() string            { return proto.CompactTextString(m) }
func (*Movement) ProtoMessage()               {}
func (*Movement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Movement) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Movement) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Movement) GetTraveled() float64 {
	if m != nil {
		return m.Traveled
	}
	return 0
}

type Empire struct {
	Id      uint32          `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Passive bool            `protobuf:"varint,2,opt,name=passive" json:"passive,omitempty"`
	Ships   map[uint64]bool `protobuf:"bytes,3,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Planets map[uint32]bool `protobuf:"bytes,4,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Color   string          `protobuf:"bytes,5,opt,name=color" json:"color,omitempty"`
}

func (m *Empire) Reset()                    { *m = Empire{} }
func (m *Empire) String() string            { return proto.CompactTextString(m) }
func (*Empire) ProtoMessage()               {}
func (*Empire) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Empire) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Empire) GetPassive() bool {
	if m != nil {
		return m.Passive
	}
	return false
}

func (m *Empire) GetShips() map[uint64]bool {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Empire) GetPlanets() map[uint32]bool {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Empire) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func init() {
	proto.RegisterType((*ID)(nil), "riseandfall.ID")
	proto.RegisterType((*Space)(nil), "riseandfall.Space")
	proto.RegisterType((*Planet)(nil), "riseandfall.Planet")
	proto.RegisterType((*Ship)(nil), "riseandfall.Ship")
	proto.RegisterType((*Movement)(nil), "riseandfall.Movement")
	proto.RegisterType((*Empire)(nil), "riseandfall.Empire")
}

func init() { proto.RegisterFile("proto/space.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcf, 0x6e, 0xd4, 0x3e,
	0x10, 0x6e, 0xfe, 0x6e, 0x76, 0xda, 0xfd, 0xe9, 0x57, 0x77, 0x41, 0x56, 0x54, 0x4a, 0xd8, 0x0b,
	0xe1, 0xb2, 0x95, 0x5a, 0x0e, 0xa5, 0x88, 0x0b, 0xa2, 0x52, 0x11, 0x82, 0xa2, 0xf4, 0x02, 0x27,
	0x94, 0x26, 0xa6, 0x6b, 0x91, 0xb5, 0xa3, 0xd8, 0xbb, 0xb0, 0x8f, 0xc0, 0xdb, 0xf0, 0x0c, 0xbc,
	0x0b, 0xef, 0x81, 0x6c, 0x27, 0x5d, 0xaf, 0x94, 0x55, 0xc5, 0xcd, 0x33, 0x9e, 0x6f, 0x3c, 0xf3,
	0x7d, 0x33, 0x86, 0xfd, 0xba, 0xe1, 0x92, 0x1f, 0x8b, 0x3a, 0x2f, 0xc8, 0x54, 0x9f, 0xd1, 0x6e,
	0x43, 0x05, 0xc9, 0x59, 0xf9, 0x35, 0xaf, 0xaa, 0xc9, 0x18, 0xdc, 0xb7, 0x6f, 0xd0, 0x7f, 0xe0,
	0xd2, 0x12, 0x3b, 0x89, 0x93, 0x0e, 0x33, 0x97, 0x96, 0x93, 0x3f, 0x1e, 0x04, 0xd7, 0x0a, 0x82,
	0x5e, 0xc0, 0xa0, 0xae, 0x72, 0x46, 0xa4, 0xc0, 0x4e, 0xe2, 0xa5, 0xbb, 0x27, 0x8f, 0xa7, 0x16,
	0x7c, 0xaa, 0x83, 0xa6, 0x1f, 0x4d, 0xc4, 0x05, 0x93, 0xcd, 0x2a, 0xeb, 0xe2, 0xd1, 0x29, 0x04,
	0x62, 0x46, 0x6b, 0x81, 0x5d, 0x0d, 0x7c, 0xd4, 0x03, 0xbc, 0x56, 0xf7, 0x06, 0x66, 0x62, 0xd5,
	0x7b, 0x64, 0x5e, 0xd3, 0x86, 0x08, 0xec, 0x6d, 0x7d, 0xef, 0xc2, 0x44, 0xb4, 0xef, 0xb5, 0xf1,
	0x68, 0x0c, 0xc1, 0x77, 0x5a, 0xca, 0x19, 0xf6, 0x13, 0x27, 0x1d, 0x65, 0xc6, 0x40, 0x0f, 0x21,
	0x9c, 0x11, 0x7a, 0x3b, 0x93, 0x38, 0xd0, 0xee, 0xd6, 0x52, 0xd1, 0x0d, 0x5f, 0xb0, 0x12, 0x87,
	0x89, 0x93, 0xfa, 0x99, 0x31, 0xe2, 0x2b, 0xd8, 0xb3, 0x9b, 0x41, 0xff, 0x83, 0xf7, 0x8d, 0xac,
	0x34, 0x33, 0xa3, 0x4c, 0x1d, 0xd1, 0x33, 0x08, 0x96, 0x79, 0xb5, 0x20, 0xd8, 0x4d, 0x9c, 0x74,
	0xf7, 0xe4, 0x60, 0xa3, 0x3c, 0x83, 0xcd, 0x4c, 0xc4, 0xb9, 0x7b, 0xe6, 0xc4, 0xef, 0x00, 0xd6,
	0x4d, 0xda, 0xe9, 0x7c, 0x93, 0xee, 0xe9, 0x66, 0xba, 0xfd, 0xcd, 0x6e, 0x67, 0xb4, 0xb6, 0x93,
	0x5d, 0xc1, 0x9e, 0xdd, 0xfa, 0xbf, 0x56, 0x67, 0xb0, 0x56, 0xc2, 0xc9, 0x6f, 0x17, 0x42, 0x53,
	0x33, 0x42, 0xe0, 0xb3, 0x7c, 0x4e, 0xda, 0x21, 0xd0, 0xe7, 0x76, 0x2c, 0x5c, 0x9d, 0xde, 0xa5,
	0x25, 0x3a, 0x80, 0xa0, 0xe6, 0xe2, 0xcb, 0x0f, 0xec, 0x69, 0x97, 0x5f, 0x73, 0xf1, 0xa9, 0x73,
	0xae, 0x5a, 0xda, 0x95, 0xf3, 0x33, 0x7a, 0x05, 0x11, 0x6f, 0x6e, 0xa8, 0xa4, 0xec, 0x16, 0x07,
	0x5a, 0xc7, 0x27, 0x3d, 0x44, 0x4d, 0xaf, 0xda, 0x18, 0xa3, 0xe4, 0x1d, 0x04, 0x61, 0x18, 0x14,
	0x9c, 0xc9, 0x86, 0x57, 0x5a, 0x1e, 0x37, 0xeb, 0x4c, 0x25, 0xa7, 0xd1, 0x1b, 0x0f, 0x8c, 0x9c,
	0xc6, 0x42, 0x87, 0x30, 0x2c, 0x38, 0x63, 0xa4, 0x90, 0xa4, 0xc4, 0x51, 0xe2, 0xa5, 0xa3, 0x6c,
	0xed, 0x40, 0x47, 0x00, 0x75, 0xc3, 0xcb, 0x45, 0x21, 0x29, 0x67, 0x78, 0xa8, 0x53, 0x5a, 0x9e,
	0xf8, 0x25, 0x8c, 0x36, 0x4a, 0xe9, 0x11, 0x6a, 0x6c, 0x33, 0x1b, 0xd9, 0x24, 0xfe, 0x74, 0xc0,
	0x57, 0x4a, 0x59, 0x5b, 0xe4, 0x6b, 0xba, 0x0e, 0x2d, 0x12, 0x34, 0x89, 0x97, 0x3b, 0x56, 0x8f,
	0xc7, 0x10, 0xce, 0xf9, 0x52, 0xdd, 0x79, 0x5a, 0xab, 0x07, 0x1b, 0x04, 0xbd, 0xe7, 0x4b, 0x32,
	0x27, 0x4c, 0x5e, 0xee, 0x64, 0x6d, 0x98, 0xd5, 0xba, 0x6f, 0xb7, 0xfe, 0x1a, 0x20, 0xaa, 0xb9,
	0xa0, 0xaa, 0x91, 0xc9, 0x07, 0x88, 0x3a, 0xa4, 0xaa, 0x58, 0xc8, 0xbc, 0x91, 0xed, 0x7c, 0x18,
	0x43, 0x75, 0x46, 0x58, 0x27, 0xaa, 0x3a, 0xa2, 0x18, 0x22, 0xd9, 0xe4, 0x4b, 0x52, 0x91, 0x52,
	0x97, 0xe2, 0x64, 0x77, 0xf6, 0xe4, 0x97, 0x0b, 0xa1, 0x19, 0x1b, 0xab, 0x3b, 0x33, 0x0c, 0x18,
	0x06, 0x75, 0x2e, 0x04, 0x5d, 0x76, 0x94, 0x74, 0x26, 0x7a, 0xde, 0x2d, 0xbe, 0xd9, 0xe0, 0xa3,
	0x9e, 0x21, 0xec, 0xd9, 0xfc, 0xf3, 0xf5, 0x4f, 0xe3, 0x6b, 0x5c, 0xd2, 0x87, 0xeb, 0xff, 0x6a,
	0xc6, 0x10, 0x14, 0xbc, 0xe2, 0x8d, 0xde, 0xf1, 0x61, 0x66, 0x8c, 0xf8, 0xec, 0x9e, 0xdd, 0xdb,
	0x2a, 0x69, 0x7c, 0x7e, 0xef, 0x37, 0xb0, 0x15, 0x7b, 0x13, 0xea, 0x5f, 0xf6, 0xf4, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xd9, 0xd6, 0x3a, 0xdd, 0x7a, 0x05, 0x00, 0x00,
}
