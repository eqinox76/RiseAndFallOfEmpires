// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/space.proto

package riseandfall

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Space struct {
	Planets map[uint32]*Planet `protobuf:"bytes,1,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Ships   map[uint64]*Ship   `protobuf:"bytes,2,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Empires map[uint32]*Empire `protobuf:"bytes,3,rep,name=empires" json:"empires,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Width   uint32             `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height  uint32             `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Space) Reset()                    { *m = Space{} }
func (m *Space) String() string            { return proto.CompactTextString(m) }
func (*Space) ProtoMessage()               {}
func (*Space) Descriptor() ([]byte, []int) { return fileDescriptorSpace, []int{0} }

func (m *Space) GetPlanets() map[uint32]*Planet {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Space) GetShips() map[uint64]*Ship {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Space) GetEmpires() map[uint32]*Empire {
	if m != nil {
		return m.Empires
	}
	return nil
}

func (m *Space) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Space) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Planet struct {
	Name      string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id        uint32          `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	PosX      uint32          `protobuf:"varint,3,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY      uint32          `protobuf:"varint,4,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
	Orbiting  map[uint64]bool `protobuf:"bytes,5,rep,name=orbiting" json:"orbiting,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Control   float32         `protobuf:"fixed32,6,opt,name=control,proto3" json:"control,omitempty"`
	Empire    uint32          `protobuf:"varint,7,opt,name=empire,proto3" json:"empire,omitempty"`
	Connected []uint32        `protobuf:"varint,8,rep,packed,name=connected" json:"connected,omitempty"`
}

func (m *Planet) Reset()                    { *m = Planet{} }
func (m *Planet) String() string            { return proto.CompactTextString(m) }
func (*Planet) ProtoMessage()               {}
func (*Planet) Descriptor() ([]byte, []int) { return fileDescriptorSpace, []int{1} }

func (m *Planet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Planet) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Planet) GetPosX() uint32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *Planet) GetPosY() uint32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *Planet) GetOrbiting() map[uint64]bool {
	if m != nil {
		return m.Orbiting
	}
	return nil
}

func (m *Planet) GetControl() float32 {
	if m != nil {
		return m.Control
	}
	return 0
}

func (m *Planet) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

func (m *Planet) GetConnected() []uint32 {
	if m != nil {
		return m.Connected
	}
	return nil
}

type Ship struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Position:
	//	*Ship_Orbiting
	//	*Ship_Moving
	Position isShip_Position `protobuf_oneof:"position"`
	Empire   uint32          `protobuf:"varint,4,opt,name=empire,proto3" json:"empire,omitempty"`
}

func (m *Ship) Reset()                    { *m = Ship{} }
func (m *Ship) String() string            { return proto.CompactTextString(m) }
func (*Ship) ProtoMessage()               {}
func (*Ship) Descriptor() ([]byte, []int) { return fileDescriptorSpace, []int{2} }

type isShip_Position interface {
	isShip_Position()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Ship_Orbiting struct {
	Orbiting uint32 `protobuf:"varint,2,opt,name=orbiting,proto3,oneof"`
}
type Ship_Moving struct {
	Moving *Movement `protobuf:"bytes,3,opt,name=moving,oneof"`
}

func (*Ship_Orbiting) isShip_Position() {}
func (*Ship_Moving) isShip_Position()   {}

func (m *Ship) GetPosition() isShip_Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Ship) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Ship) GetOrbiting() uint32 {
	if x, ok := m.GetPosition().(*Ship_Orbiting); ok {
		return x.Orbiting
	}
	return 0
}

func (m *Ship) GetMoving() *Movement {
	if x, ok := m.GetPosition().(*Ship_Moving); ok {
		return x.Moving
	}
	return nil
}

func (m *Ship) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Ship) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Ship_OneofMarshaler, _Ship_OneofUnmarshaler, _Ship_OneofSizer, []interface{}{
		(*Ship_Orbiting)(nil),
		(*Ship_Moving)(nil),
	}
}

func _Ship_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Moving); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Ship.Position has unexpected type %T", x)
	}
	return nil
}

func _Ship_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Ship)
	switch tag {
	case 2: // position.orbiting
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Position = &Ship_Orbiting{uint32(x)}
		return true, err
	case 3: // position.moving
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Movement)
		err := b.DecodeMessage(msg)
		m.Position = &Ship_Moving{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Ship_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		s := proto.Size(x.Moving)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Movement struct {
	Start    uint32  `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End      uint32  `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Traveled float64 `protobuf:"fixed64,3,opt,name=traveled,proto3" json:"traveled,omitempty"`
}

func (m *Movement) Reset()                    { *m = Movement{} }
func (m *Movement) String() string            { return proto.CompactTextString(m) }
func (*Movement) ProtoMessage()               {}
func (*Movement) Descriptor() ([]byte, []int) { return fileDescriptorSpace, []int{3} }

func (m *Movement) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Movement) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Movement) GetTraveled() float64 {
	if m != nil {
		return m.Traveled
	}
	return 0
}

type Empire struct {
	Id      uint32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Passive bool            `protobuf:"varint,2,opt,name=passive,proto3" json:"passive,omitempty"`
	Ships   map[uint64]bool `protobuf:"bytes,3,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Planets map[uint32]bool `protobuf:"bytes,4,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Color   string          `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *Empire) Reset()                    { *m = Empire{} }
func (m *Empire) String() string            { return proto.CompactTextString(m) }
func (*Empire) ProtoMessage()               {}
func (*Empire) Descriptor() ([]byte, []int) { return fileDescriptorSpace, []int{4} }

func (m *Empire) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Empire) GetPassive() bool {
	if m != nil {
		return m.Passive
	}
	return false
}

func (m *Empire) GetShips() map[uint64]bool {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Empire) GetPlanets() map[uint32]bool {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Empire) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func init() {
	proto.RegisterType((*Space)(nil), "riseandfall.Space")
	proto.RegisterType((*Planet)(nil), "riseandfall.Planet")
	proto.RegisterType((*Ship)(nil), "riseandfall.Ship")
	proto.RegisterType((*Movement)(nil), "riseandfall.Movement")
	proto.RegisterType((*Empire)(nil), "riseandfall.Empire")
}
func (m *Space) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Space) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0xa
			i++
			v := m.Planets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Ships) > 0 {
		for k, _ := range m.Ships {
			dAtA[i] = 0x12
			i++
			v := m.Ships[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Empires) > 0 {
		for k, _ := range m.Empires {
			dAtA[i] = 0x1a
			i++
			v := m.Empires[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *Planet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Planet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.PosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosY))
	}
	if len(m.Orbiting) > 0 {
		for k, _ := range m.Orbiting {
			dAtA[i] = 0x2a
			i++
			v := m.Orbiting[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.Control != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Space(dAtA, i, uint32(math.Float32bits(float32(m.Control))))
	}
	if m.Empire != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		dAtA5 := make([]byte, len(m.Connected)*10)
		var j4 int
		for _, num := range m.Connected {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintSpace(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *Ship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ship) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.Position != nil {
		nn6, err := m.Position.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.Empire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	return i, nil
}

func (m *Ship_Orbiting) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintSpace(dAtA, i, uint64(m.Orbiting))
	return i, nil
}
func (m *Ship_Moving) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Moving != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Moving.Size()))
		n7, err := m.Moving.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Movement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Movement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.End))
	}
	if m.Traveled != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Space(dAtA, i, uint64(math.Float64bits(float64(m.Traveled))))
	}
	return i, nil
}

func (m *Empire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empire) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.Passive {
		dAtA[i] = 0x10
		i++
		if m.Passive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ships) > 0 {
		for k, _ := range m.Ships {
			dAtA[i] = 0x1a
			i++
			v := m.Ships[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0x22
			i++
			v := m.Planets[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Color) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Color)))
		i += copy(dAtA[i:], m.Color)
	}
	return i, nil
}

func encodeFixed64Space(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Space(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSpace(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Ships) > 0 {
		for k, v := range m.Ships {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Empires) > 0 {
		for k, v := range m.Empires {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Width != 0 {
		n += 1 + sovSpace(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovSpace(uint64(m.Height))
	}
	return n
}

func (m *Planet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.PosX != 0 {
		n += 1 + sovSpace(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovSpace(uint64(m.PosY))
	}
	if len(m.Orbiting) > 0 {
		for k, v := range m.Orbiting {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Control != 0 {
		n += 5
	}
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		l = 0
		for _, e := range m.Connected {
			l += sovSpace(uint64(e))
		}
		n += 1 + sovSpace(uint64(l)) + l
	}
	return n
}

func (m *Ship) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.Position != nil {
		n += m.Position.Size()
	}
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	return n
}

func (m *Ship_Orbiting) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSpace(uint64(m.Orbiting))
	return n
}
func (m *Ship_Moving) Size() (n int) {
	var l int
	_ = l
	if m.Moving != nil {
		l = m.Moving.Size()
		n += 1 + l + sovSpace(uint64(l))
	}
	return n
}
func (m *Movement) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovSpace(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSpace(uint64(m.End))
	}
	if m.Traveled != 0 {
		n += 9
	}
	return n
}

func (m *Empire) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.Passive {
		n += 2
	}
	if len(m.Ships) > 0 {
		for k, v := range m.Ships {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	return n
}

func sovSpace(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSpace(x uint64) (n int) {
	return sovSpace(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Space) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]*Planet)
			}
			var mapkey uint32
			var mapvalue *Planet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Planet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ships == nil {
				m.Ships = make(map[uint64]*Ship)
			}
			var mapkey uint64
			var mapvalue *Ship
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ship{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ships[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empires == nil {
				m.Empires = make(map[uint32]*Empire)
			}
			var mapkey uint32
			var mapvalue *Empire
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Empire{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Empires[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Planet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Planet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Planet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orbiting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Orbiting == nil {
				m.Orbiting = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Orbiting[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Control = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Connected = append(m.Connected, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpace
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Connected = append(m.Connected, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orbiting", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Position = &Ship_Orbiting{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moving", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Movement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Position = &Ship_Moving{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Movement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Movement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Movement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traveled", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Traveled = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ships == nil {
				m.Ships = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ships[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]bool)
			}
			var mapkey uint32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpace(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSpace
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpace(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpace = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpace   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/space.proto", fileDescriptorSpace) }

var fileDescriptorSpace = []byte{
	// 590 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0x8e, 0xff, 0xc6, 0x99, 0x34, 0x3f, 0xb5, 0xdb, 0xfc, 0xd0, 0xca, 0x2a, 0xc1, 0xe4, 0x42,
	0xb8, 0xa4, 0x52, 0xcb, 0xa1, 0x04, 0x71, 0xa9, 0x54, 0xa9, 0x12, 0x82, 0x20, 0xf7, 0x02, 0x27,
	0xe4, 0xc6, 0x4b, 0xb3, 0xc2, 0xf1, 0x5a, 0xde, 0x25, 0x90, 0x47, 0xe0, 0x0d, 0x38, 0xf3, 0x04,
	0x3c, 0x06, 0x37, 0x78, 0x04, 0x14, 0x5e, 0x04, 0xed, 0xae, 0xdd, 0x6c, 0x24, 0x47, 0x15, 0xb7,
	0x9d, 0xf1, 0xf7, 0xcd, 0xce, 0x7c, 0x9f, 0x67, 0xe1, 0xa0, 0x28, 0x99, 0x60, 0xc7, 0xbc, 0x48,
	0x66, 0x64, 0xac, 0xce, 0xa8, 0x5b, 0x52, 0x4e, 0x92, 0x3c, 0x7d, 0x9f, 0x64, 0xd9, 0xf0, 0xa7,
	0x03, 0xde, 0x95, 0xfc, 0x88, 0x9e, 0x42, 0xbb, 0xc8, 0x92, 0x9c, 0x08, 0x8e, 0xad, 0xc8, 0x19,
	0x75, 0x4f, 0x1e, 0x8c, 0x0d, 0xe0, 0x58, 0x81, 0xc6, 0xaf, 0x35, 0xe2, 0x22, 0x17, 0xe5, 0x2a,
	0xae, 0xf1, 0xe8, 0x14, 0x3c, 0x3e, 0xa7, 0x05, 0xc7, 0xb6, 0x22, 0xde, 0x6f, 0x20, 0x5e, 0xc9,
	0xef, 0x9a, 0xa6, 0xb1, 0xf2, 0x3e, 0xb2, 0x28, 0x68, 0x49, 0x38, 0x76, 0x76, 0xde, 0x77, 0xa1,
	0x11, 0xd5, 0x7d, 0x15, 0x1e, 0xf5, 0xc1, 0xfb, 0x44, 0x53, 0x31, 0xc7, 0x6e, 0x64, 0x8d, 0x7a,
	0xb1, 0x0e, 0xd0, 0x3d, 0xf0, 0xe7, 0x84, 0xde, 0xcc, 0x05, 0xf6, 0x54, 0xba, 0x8a, 0xc2, 0x29,
	0xec, 0x99, 0x6d, 0xa3, 0x7d, 0x70, 0x3e, 0x90, 0x15, 0xb6, 0x14, 0x48, 0x1e, 0xd1, 0x63, 0xf0,
	0x96, 0x49, 0xf6, 0x91, 0x60, 0x3b, 0xb2, 0x46, 0xdd, 0x93, 0xc3, 0xad, 0x46, 0x34, 0x37, 0xd6,
	0x88, 0x89, 0x7d, 0x66, 0x85, 0x2f, 0x00, 0x36, 0xe3, 0x98, 0xe5, 0x5c, 0x5d, 0xee, 0xd1, 0x76,
	0xb9, 0x83, 0xed, 0xb9, 0xe6, 0xb4, 0x30, 0x8b, 0x4d, 0x61, 0xcf, 0x1c, 0xf2, 0x5f, 0xbb, 0xd3,
	0x5c, 0xa3, 0xe0, 0xf0, 0x9b, 0x0d, 0xbe, 0xee, 0x19, 0x21, 0x70, 0xf3, 0x64, 0x41, 0x54, 0xb1,
	0x4e, 0xac, 0xce, 0xe8, 0x3f, 0xb0, 0x69, 0xaa, 0x4a, 0xf5, 0x62, 0x9b, 0xa6, 0xe8, 0x10, 0xbc,
	0x82, 0xf1, 0x77, 0x9f, 0xb1, 0xa3, 0x52, 0x6e, 0xc1, 0xf8, 0x9b, 0x3a, 0xb9, 0xaa, 0x04, 0x96,
	0xc9, 0xb7, 0xe8, 0x39, 0x04, 0xac, 0xbc, 0xa6, 0x82, 0xe6, 0x37, 0xd8, 0x53, 0x8e, 0x3d, 0x6c,
	0x10, 0x6a, 0x3c, 0xad, 0x30, 0xda, 0xb3, 0x5b, 0x0a, 0xc2, 0xd0, 0x9e, 0xb1, 0x5c, 0x94, 0x2c,
	0xc3, 0x7e, 0x64, 0x8d, 0xec, 0xb8, 0x0e, 0xa5, 0x71, 0xda, 0x59, 0xdc, 0xd6, 0xc6, 0xe9, 0x08,
	0x1d, 0x41, 0x67, 0xc6, 0xf2, 0x9c, 0xcc, 0x04, 0x49, 0x71, 0x10, 0x39, 0xa3, 0x5e, 0xbc, 0x49,
	0x84, 0xcf, 0xa0, 0xb7, 0x75, 0x55, 0x83, 0x11, 0x7d, 0x53, 0xb9, 0xc0, 0x14, 0xe9, 0x8b, 0x05,
	0xae, 0x74, 0xa2, 0x92, 0x43, 0x73, 0xa4, 0x1c, 0x47, 0xc6, 0x90, 0x4a, 0xa4, 0xcb, 0x96, 0x31,
	0xc3, 0x31, 0xf8, 0x0b, 0xb6, 0x94, 0xdf, 0x1c, 0xe5, 0xc5, 0xff, 0x5b, 0x02, 0xbc, 0x64, 0x4b,
	0xb2, 0x20, 0xb9, 0xb8, 0x6c, 0xc5, 0x15, 0xcc, 0x18, 0xcd, 0x35, 0x47, 0x3b, 0x07, 0x08, 0x0a,
	0xc6, 0xa9, 0xa0, 0x2c, 0x1f, 0xbe, 0x82, 0xa0, 0x66, 0xca, 0x8e, 0xb9, 0x48, 0x4a, 0x51, 0xf9,
	0xaf, 0x03, 0x39, 0x19, 0xc9, 0x6b, 0xd3, 0xe4, 0x11, 0x85, 0x10, 0x88, 0x32, 0x59, 0x92, 0x8c,
	0xa4, 0xaa, 0x15, 0x2b, 0xbe, 0x8d, 0x87, 0xdf, 0x6d, 0xf0, 0xf5, 0x6f, 0x61, 0x4c, 0xa7, 0xcd,
	0xc6, 0xd0, 0x2e, 0x12, 0xce, 0xe9, 0xb2, 0x96, 0xa4, 0x0e, 0xd1, 0x93, 0x7a, 0x85, 0xf5, 0x2e,
	0x0e, 0x1a, 0x7e, 0xb2, 0x86, 0x1d, 0x9e, 0x6c, 0xde, 0x0c, 0x57, 0xf1, 0xa2, 0x26, 0x5e, 0xf3,
	0xa3, 0xd1, 0x07, 0x6f, 0xc6, 0x32, 0x56, 0xaa, 0x6d, 0xed, 0xc4, 0x3a, 0x08, 0xcf, 0xee, 0xd8,
	0xad, 0x9d, 0x96, 0x86, 0x93, 0x3b, 0xd7, 0x7c, 0x27, 0xf7, 0x7c, 0xff, 0xc7, 0x7a, 0x60, 0xfd,
	0x5a, 0x0f, 0xac, 0xdf, 0xeb, 0x81, 0xf5, 0xf5, 0xcf, 0xa0, 0x75, 0xed, 0xab, 0xb7, 0xf2, 0xf4,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0c, 0xcf, 0x94, 0x07, 0x40, 0x05, 0x00, 0x00,
}
