// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/space.proto

package riseandfall

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ID) Reset()         { *m = ID{} }
func (m *ID) String() string { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()    {}
func (*ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{0}
}
func (m *ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ID.Merge(dst, src)
}
func (m *ID) XXX_Size() int {
	return m.Size()
}
func (m *ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ID proto.InternalMessageInfo

func (m *ID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Space struct {
	Planets              map[uint32]*Planet `protobuf:"bytes,1,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Ships                map[uint64]*Ship   `protobuf:"bytes,2,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Empires              map[uint32]*Empire `protobuf:"bytes,3,rep,name=empires" json:"empires,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Width                uint32             `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height               uint32             `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Round                uint64             `protobuf:"varint,6,opt,name=round,proto3" json:"round,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Space) Reset()         { *m = Space{} }
func (m *Space) String() string { return proto.CompactTextString(m) }
func (*Space) ProtoMessage()    {}
func (*Space) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{1}
}
func (m *Space) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Space) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Space.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Space) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Space.Merge(dst, src)
}
func (m *Space) XXX_Size() int {
	return m.Size()
}
func (m *Space) XXX_DiscardUnknown() {
	xxx_messageInfo_Space.DiscardUnknown(m)
}

var xxx_messageInfo_Space proto.InternalMessageInfo

func (m *Space) GetPlanets() map[uint32]*Planet {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Space) GetShips() map[uint64]*Ship {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Space) GetEmpires() map[uint32]*Empire {
	if m != nil {
		return m.Empires
	}
	return nil
}

func (m *Space) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Space) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Space) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type Planet struct {
	Name                 string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id                   uint32          `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	PosX                 uint32          `protobuf:"varint,3,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY                 uint32          `protobuf:"varint,4,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
	Orbiting             map[uint64]bool `protobuf:"bytes,5,rep,name=orbiting" json:"orbiting,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Control              float32         `protobuf:"fixed32,6,opt,name=control,proto3" json:"control,omitempty"`
	Empire               uint32          `protobuf:"varint,7,opt,name=empire,proto3" json:"empire,omitempty"`
	Connected            []uint32        `protobuf:"varint,8,rep,packed,name=connected" json:"connected,omitempty"`
	Production           float32         `protobuf:"fixed32,9,opt,name=production,proto3" json:"production,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Planet) Reset()         { *m = Planet{} }
func (m *Planet) String() string { return proto.CompactTextString(m) }
func (*Planet) ProtoMessage()    {}
func (*Planet) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{2}
}
func (m *Planet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Planet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Planet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Planet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Planet.Merge(dst, src)
}
func (m *Planet) XXX_Size() int {
	return m.Size()
}
func (m *Planet) XXX_DiscardUnknown() {
	xxx_messageInfo_Planet.DiscardUnknown(m)
}

var xxx_messageInfo_Planet proto.InternalMessageInfo

func (m *Planet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Planet) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Planet) GetPosX() uint32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *Planet) GetPosY() uint32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *Planet) GetOrbiting() map[uint64]bool {
	if m != nil {
		return m.Orbiting
	}
	return nil
}

func (m *Planet) GetControl() float32 {
	if m != nil {
		return m.Control
	}
	return 0
}

func (m *Planet) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

func (m *Planet) GetConnected() []uint32 {
	if m != nil {
		return m.Connected
	}
	return nil
}

func (m *Planet) GetProduction() float32 {
	if m != nil {
		return m.Production
	}
	return 0
}

type Ship struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Position:
	//	*Ship_Orbiting
	//	*Ship_Moving
	Position             isShip_Position `protobuf_oneof:"position"`
	Empire               uint32          `protobuf:"varint,4,opt,name=empire,proto3" json:"empire,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Ship) Reset()         { *m = Ship{} }
func (m *Ship) String() string { return proto.CompactTextString(m) }
func (*Ship) ProtoMessage()    {}
func (*Ship) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{3}
}
func (m *Ship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Ship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ship.Merge(dst, src)
}
func (m *Ship) XXX_Size() int {
	return m.Size()
}
func (m *Ship) XXX_DiscardUnknown() {
	xxx_messageInfo_Ship.DiscardUnknown(m)
}

var xxx_messageInfo_Ship proto.InternalMessageInfo

type isShip_Position interface {
	isShip_Position()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Ship_Orbiting struct {
	Orbiting uint32 `protobuf:"varint,2,opt,name=orbiting,proto3,oneof"`
}
type Ship_Moving struct {
	Moving *Movement `protobuf:"bytes,3,opt,name=moving,oneof"`
}

func (*Ship_Orbiting) isShip_Position() {}
func (*Ship_Moving) isShip_Position()   {}

func (m *Ship) GetPosition() isShip_Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Ship) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Ship) GetOrbiting() uint32 {
	if x, ok := m.GetPosition().(*Ship_Orbiting); ok {
		return x.Orbiting
	}
	return 0
}

func (m *Ship) GetMoving() *Movement {
	if x, ok := m.GetPosition().(*Ship_Moving); ok {
		return x.Moving
	}
	return nil
}

func (m *Ship) GetEmpire() uint32 {
	if m != nil {
		return m.Empire
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Ship) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Ship_OneofMarshaler, _Ship_OneofUnmarshaler, _Ship_OneofSizer, []interface{}{
		(*Ship_Orbiting)(nil),
		(*Ship_Moving)(nil),
	}
}

func _Ship_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Moving); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Ship.Position has unexpected type %T", x)
	}
	return nil
}

func _Ship_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Ship)
	switch tag {
	case 2: // position.orbiting
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Position = &Ship_Orbiting{uint32(x)}
		return true, err
	case 3: // position.moving
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Movement)
		err := b.DecodeMessage(msg)
		m.Position = &Ship_Moving{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Ship_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Ship)
	// position
	switch x := m.Position.(type) {
	case *Ship_Orbiting:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Orbiting))
	case *Ship_Moving:
		s := proto.Size(x.Moving)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Movement struct {
	Start                uint32   `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint32   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Traveled             float64  `protobuf:"fixed64,3,opt,name=traveled,proto3" json:"traveled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Movement) Reset()         { *m = Movement{} }
func (m *Movement) String() string { return proto.CompactTextString(m) }
func (*Movement) ProtoMessage()    {}
func (*Movement) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{4}
}
func (m *Movement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Movement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Movement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Movement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Movement.Merge(dst, src)
}
func (m *Movement) XXX_Size() int {
	return m.Size()
}
func (m *Movement) XXX_DiscardUnknown() {
	xxx_messageInfo_Movement.DiscardUnknown(m)
}

var xxx_messageInfo_Movement proto.InternalMessageInfo

func (m *Movement) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Movement) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Movement) GetTraveled() float64 {
	if m != nil {
		return m.Traveled
	}
	return 0
}

type Empire struct {
	Id                   uint32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Passive              bool            `protobuf:"varint,2,opt,name=passive,proto3" json:"passive,omitempty"`
	Ships                map[uint64]bool `protobuf:"bytes,3,rep,name=ships" json:"ships,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Planets              map[uint32]bool `protobuf:"bytes,4,rep,name=planets" json:"planets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Color                string          `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Empire) Reset()         { *m = Empire{} }
func (m *Empire) String() string { return proto.CompactTextString(m) }
func (*Empire) ProtoMessage()    {}
func (*Empire) Descriptor() ([]byte, []int) {
	return fileDescriptor_space_c5268b713f9dd590, []int{5}
}
func (m *Empire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empire.Merge(dst, src)
}
func (m *Empire) XXX_Size() int {
	return m.Size()
}
func (m *Empire) XXX_DiscardUnknown() {
	xxx_messageInfo_Empire.DiscardUnknown(m)
}

var xxx_messageInfo_Empire proto.InternalMessageInfo

func (m *Empire) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Empire) GetPassive() bool {
	if m != nil {
		return m.Passive
	}
	return false
}

func (m *Empire) GetShips() map[uint64]bool {
	if m != nil {
		return m.Ships
	}
	return nil
}

func (m *Empire) GetPlanets() map[uint32]bool {
	if m != nil {
		return m.Planets
	}
	return nil
}

func (m *Empire) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func init() {
	proto.RegisterType((*ID)(nil), "riseandfall.ID")
	proto.RegisterType((*Space)(nil), "riseandfall.Space")
	proto.RegisterMapType((map[uint32]*Empire)(nil), "riseandfall.Space.EmpiresEntry")
	proto.RegisterMapType((map[uint32]*Planet)(nil), "riseandfall.Space.PlanetsEntry")
	proto.RegisterMapType((map[uint64]*Ship)(nil), "riseandfall.Space.ShipsEntry")
	proto.RegisterType((*Planet)(nil), "riseandfall.Planet")
	proto.RegisterMapType((map[uint64]bool)(nil), "riseandfall.Planet.OrbitingEntry")
	proto.RegisterType((*Ship)(nil), "riseandfall.Ship")
	proto.RegisterType((*Movement)(nil), "riseandfall.Movement")
	proto.RegisterType((*Empire)(nil), "riseandfall.Empire")
	proto.RegisterMapType((map[uint32]bool)(nil), "riseandfall.Empire.PlanetsEntry")
	proto.RegisterMapType((map[uint64]bool)(nil), "riseandfall.Empire.ShipsEntry")
}
func (m *ID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Space) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Space) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0xa
			i++
			v := m.Planets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Ships) > 0 {
		for k, _ := range m.Ships {
			dAtA[i] = 0x12
			i++
			v := m.Ships[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Empires) > 0 {
		for k, _ := range m.Empires {
			dAtA[i] = 0x1a
			i++
			v := m.Empires[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSpace(uint64(msgSize))
			}
			mapSize := 1 + sovSpace(uint64(k)) + msgSize
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSpace(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Height))
	}
	if m.Round != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Round))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Planet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Planet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.PosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.PosY))
	}
	if len(m.Orbiting) > 0 {
		for k, _ := range m.Orbiting {
			dAtA[i] = 0x2a
			i++
			v := m.Orbiting[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.Control != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Control))))
		i += 4
	}
	if m.Empire != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		dAtA5 := make([]byte, len(m.Connected)*10)
		var j4 int
		for _, num := range m.Connected {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintSpace(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.Production != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Production))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ship) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.Position != nil {
		nn6, err := m.Position.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.Empire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Empire))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ship_Orbiting) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintSpace(dAtA, i, uint64(m.Orbiting))
	return i, nil
}
func (m *Ship_Moving) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Moving != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Moving.Size()))
		n7, err := m.Moving.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Movement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Movement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.End))
	}
	if m.Traveled != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Traveled))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Empire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empire) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpace(dAtA, i, uint64(m.Id))
	}
	if m.Passive {
		dAtA[i] = 0x10
		i++
		if m.Passive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ships) > 0 {
		for k, _ := range m.Ships {
			dAtA[i] = 0x1a
			i++
			v := m.Ships[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Planets) > 0 {
		for k, _ := range m.Planets {
			dAtA[i] = 0x22
			i++
			v := m.Planets[k]
			mapSize := 1 + sovSpace(uint64(k)) + 1 + 1
			i = encodeVarintSpace(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintSpace(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Color) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpace(dAtA, i, uint64(len(m.Color)))
		i += copy(dAtA[i:], m.Color)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSpace(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ID) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Ships) > 0 {
		for k, v := range m.Ships {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Empires) > 0 {
		for k, v := range m.Empires {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpace(uint64(l))
			}
			mapEntrySize := 1 + sovSpace(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Width != 0 {
		n += 1 + sovSpace(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovSpace(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovSpace(uint64(m.Round))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Planet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.PosX != 0 {
		n += 1 + sovSpace(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovSpace(uint64(m.PosY))
	}
	if len(m.Orbiting) > 0 {
		for k, v := range m.Orbiting {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if m.Control != 0 {
		n += 5
	}
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	if len(m.Connected) > 0 {
		l = 0
		for _, e := range m.Connected {
			l += sovSpace(uint64(e))
		}
		n += 1 + sovSpace(uint64(l)) + l
	}
	if m.Production != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ship) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.Position != nil {
		n += m.Position.Size()
	}
	if m.Empire != 0 {
		n += 1 + sovSpace(uint64(m.Empire))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ship_Orbiting) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSpace(uint64(m.Orbiting))
	return n
}
func (m *Ship_Moving) Size() (n int) {
	var l int
	_ = l
	if m.Moving != nil {
		l = m.Moving.Size()
		n += 1 + l + sovSpace(uint64(l))
	}
	return n
}
func (m *Movement) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovSpace(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSpace(uint64(m.End))
	}
	if m.Traveled != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empire) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpace(uint64(m.Id))
	}
	if m.Passive {
		n += 2
	}
	if len(m.Ships) > 0 {
		for k, v := range m.Ships {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	if len(m.Planets) > 0 {
		for k, v := range m.Planets {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpace(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovSpace(uint64(mapEntrySize))
		}
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovSpace(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSpace(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSpace(x uint64) (n int) {
	return sovSpace(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Space) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]*Planet)
			}
			var mapkey uint32
			var mapvalue *Planet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Planet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ships == nil {
				m.Ships = make(map[uint64]*Ship)
			}
			var mapkey uint64
			var mapvalue *Ship
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ship{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ships[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empires == nil {
				m.Empires = make(map[uint32]*Empire)
			}
			var mapkey uint32
			var mapvalue *Empire
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSpace
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Empire{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Empires[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Planet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Planet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Planet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orbiting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Orbiting == nil {
				m.Orbiting = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Orbiting[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Control = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Connected = append(m.Connected, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpace
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Connected = append(m.Connected, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Production", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Production = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orbiting", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Position = &Ship_Orbiting{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moving", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Movement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Position = &Ship_Moving{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empire", wireType)
			}
			m.Empire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Empire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Movement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Movement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Movement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traveled", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Traveled = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ships == nil {
				m.Ships = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ships[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Planets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Planets == nil {
				m.Planets = make(map[uint32]bool)
			}
			var mapkey uint32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpace
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpace(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpace
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Planets[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpace
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpace(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpace
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSpace
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpace
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpace(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpace = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpace   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/space.proto", fileDescriptor_space_c5268b713f9dd590) }

var fileDescriptor_space_c5268b713f9dd590 = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd4, 0x30,
	0x10, 0xae, 0xf3, 0xb3, 0x3f, 0xd3, 0x2e, 0x6a, 0xdd, 0x05, 0x59, 0xab, 0xb2, 0x84, 0xbd, 0x10,
	0x2e, 0x5b, 0xa9, 0xe5, 0x50, 0x8a, 0xb8, 0x54, 0x54, 0x2a, 0x42, 0x50, 0x94, 0x5e, 0xe0, 0x84,
	0xd2, 0xc4, 0x74, 0x2d, 0xb2, 0x76, 0x14, 0xbb, 0x0b, 0x7d, 0x04, 0xde, 0x80, 0xc7, 0xe0, 0x19,
	0x38, 0x71, 0xe4, 0x11, 0x50, 0x11, 0xef, 0x81, 0x6c, 0x27, 0xad, 0x57, 0x4a, 0x55, 0x71, 0xf3,
	0x8c, 0xe7, 0x1b, 0xcf, 0x7c, 0xdf, 0x8c, 0x61, 0xa3, 0xac, 0x84, 0x12, 0xdb, 0xb2, 0x4c, 0x33,
	0x3a, 0x35, 0x67, 0xbc, 0x5a, 0x31, 0x49, 0x53, 0x9e, 0x7f, 0x4c, 0x8b, 0x62, 0x32, 0x04, 0xef,
	0xe5, 0x0b, 0x7c, 0x07, 0x3c, 0x96, 0x13, 0x14, 0xa1, 0xb8, 0x9f, 0x78, 0x2c, 0x9f, 0xfc, 0xf5,
	0x21, 0x3c, 0xd1, 0x10, 0xfc, 0x14, 0xba, 0x65, 0x91, 0x72, 0xaa, 0x24, 0x41, 0x91, 0x1f, 0xaf,
	0xee, 0x3c, 0x98, 0x3a, 0xf0, 0xa9, 0x09, 0x9a, 0xbe, 0xb5, 0x11, 0x87, 0x5c, 0x55, 0x17, 0x49,
	0x13, 0x8f, 0x77, 0x21, 0x94, 0x33, 0x56, 0x4a, 0xe2, 0x19, 0xe0, 0xfd, 0x16, 0xe0, 0x89, 0xbe,
	0xb7, 0x30, 0x1b, 0xab, 0xdf, 0xa3, 0xf3, 0x92, 0x55, 0x54, 0x12, 0xff, 0xc6, 0xf7, 0x0e, 0x6d,
	0x44, 0xfd, 0x5e, 0x1d, 0x8f, 0x87, 0x10, 0x7e, 0x66, 0xb9, 0x9a, 0x91, 0x20, 0x42, 0xf1, 0x20,
	0xb1, 0x06, 0xbe, 0x07, 0x9d, 0x19, 0x65, 0x67, 0x33, 0x45, 0x42, 0xe3, 0xae, 0x2d, 0x1d, 0x5d,
	0x89, 0x73, 0x9e, 0x93, 0x4e, 0x84, 0xe2, 0x20, 0xb1, 0xc6, 0xe8, 0x18, 0xd6, 0xdc, 0x66, 0xf0,
	0x3a, 0xf8, 0x9f, 0xe8, 0x85, 0x61, 0x66, 0x90, 0xe8, 0x23, 0x7e, 0x0c, 0xe1, 0x22, 0x2d, 0xce,
	0x29, 0xf1, 0x22, 0x14, 0xaf, 0xee, 0x6c, 0x2e, 0x95, 0x67, 0xb1, 0x89, 0x8d, 0xd8, 0xf7, 0xf6,
	0xd0, 0xe8, 0x15, 0xc0, 0x75, 0x93, 0x6e, 0xba, 0xc0, 0xa6, 0x7b, 0xb4, 0x9c, 0x6e, 0x63, 0xb9,
	0xdb, 0x19, 0x2b, 0xdd, 0x64, 0xc7, 0xb0, 0xe6, 0xb6, 0xfe, 0xbf, 0xd5, 0x59, 0xac, 0x93, 0x70,
	0xf2, 0xc3, 0x83, 0x8e, 0xad, 0x19, 0x63, 0x08, 0x78, 0x3a, 0xa7, 0xf5, 0x10, 0x98, 0x73, 0x3d,
	0x16, 0x9e, 0x49, 0xef, 0xb1, 0x1c, 0x6f, 0x42, 0x58, 0x0a, 0xf9, 0xe1, 0x0b, 0xf1, 0x8d, 0x2b,
	0x28, 0x85, 0x7c, 0xd7, 0x38, 0x2f, 0x6a, 0xda, 0xb5, 0xf3, 0x3d, 0x7e, 0x0e, 0x3d, 0x51, 0x9d,
	0x32, 0xc5, 0xf8, 0x19, 0x09, 0x8d, 0x8e, 0x0f, 0x5b, 0x88, 0x9a, 0x1e, 0xd7, 0x31, 0x56, 0xc9,
	0x2b, 0x08, 0x26, 0xd0, 0xcd, 0x04, 0x57, 0x95, 0x28, 0x8c, 0x3c, 0x5e, 0xd2, 0x98, 0x5a, 0x4e,
	0xab, 0x37, 0xe9, 0x5a, 0x39, 0xad, 0x85, 0xb7, 0xa0, 0x9f, 0x09, 0xce, 0x69, 0xa6, 0x68, 0x4e,
	0x7a, 0x91, 0x1f, 0x0f, 0x92, 0x6b, 0x07, 0x1e, 0x03, 0x94, 0x95, 0xc8, 0xcf, 0x33, 0xc5, 0x04,
	0x27, 0x7d, 0x93, 0xd2, 0xf1, 0x8c, 0x9e, 0xc1, 0x60, 0xa9, 0x94, 0x16, 0xa1, 0x86, 0x2e, 0xb3,
	0x3d, 0x97, 0xc4, 0xaf, 0x08, 0x02, 0xad, 0x94, 0xb3, 0x45, 0x81, 0xa1, 0x6b, 0xcb, 0x21, 0xc1,
	0x90, 0x78, 0xb4, 0xe2, 0xf4, 0xb8, 0x0d, 0x9d, 0xb9, 0x58, 0xe8, 0x3b, 0xdf, 0x68, 0x75, 0x77,
	0x89, 0xa0, 0xd7, 0x62, 0x41, 0xe7, 0x94, 0xab, 0xa3, 0x95, 0xa4, 0x0e, 0x73, 0x5a, 0x0f, 0xdc,
	0xd6, 0x0f, 0x00, 0x7a, 0xa5, 0x90, 0x4c, 0x37, 0x32, 0x79, 0x03, 0xbd, 0x06, 0xa9, 0x2b, 0x96,
	0x2a, 0xad, 0x54, 0x3d, 0x1f, 0xd6, 0xd0, 0x9d, 0x51, 0xde, 0x88, 0xaa, 0x8f, 0x78, 0x04, 0x3d,
	0x55, 0xa5, 0x0b, 0x5a, 0xd0, 0xdc, 0x94, 0x82, 0x92, 0x2b, 0x7b, 0xf2, 0xdd, 0x83, 0x8e, 0x1d,
	0x1b, 0xa7, 0x3b, 0x3b, 0x0c, 0x04, 0xba, 0x65, 0x2a, 0x25, 0x5b, 0x34, 0x94, 0x34, 0x26, 0x7e,
	0xd2, 0x2c, 0xbe, 0xdd, 0xe0, 0x71, 0xcb, 0x10, 0xb6, 0x6c, 0xfe, 0xfe, 0xf5, 0x4f, 0x13, 0x18,
	0x5c, 0xd4, 0x86, 0x6b, 0xff, 0x6a, 0x86, 0x10, 0x66, 0xa2, 0x10, 0x95, 0xd9, 0xf1, 0x7e, 0x62,
	0x8d, 0xd1, 0xde, 0x2d, 0xbb, 0x77, 0xa3, 0xa4, 0xa3, 0xfd, 0x5b, 0xbf, 0x81, 0x1b, 0xb1, 0x07,
	0xeb, 0x3f, 0x2f, 0xc7, 0xe8, 0xd7, 0xe5, 0x18, 0xfd, 0xbe, 0x1c, 0xa3, 0x6f, 0x7f, 0xc6, 0x2b,
	0xa7, 0x1d, 0xf3, 0xef, 0xee, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xfb, 0xe9, 0xe3, 0x3c, 0x8c,
	0x05, 0x00, 0x00,
}
